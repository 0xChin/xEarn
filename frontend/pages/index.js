import Head from "next/head";
import styles from "../styles/Home.module.css";
import {
  useAccount,
  useConnect,
  useContractWrite,
  useDisconnect,
  useNetwork,
  usePrepareContractWrite,
  useSwitchNetwork,
} from "wagmi";
import { polygon } from "@wagmi/chains";
import { InjectedConnector } from "wagmi/connectors/injected";
import { useEffect, useState } from "react";
import {
  shortenAddress,
  transformSymbol,
  numberWithCommas,
} from "../utils/utils";
import { ethers } from "ethers";
import XEARN_ABI from "../utils/abi/xEarn.json";
import VAULT_MANAGER_ABI from "../utils/abi/VaultManager.json";
import WETH_ABI from "../utils/abi/Weth.json";

export default function Home({ vaults }) {
  const [mounted, setMounted] = useState(false);
  const { address, isConnected } = useAccount();
  const { connect } = useConnect({
    connector: new InjectedConnector(),
  });
  const { disconnect } = useDisconnect();
  const { chain } = useNetwork();
  const { switchNetwork } = useSwitchNetwork();
  const [depositedAmounts, setDepositedAmounts] = useState({});

  const depositedAmount = numberWithCommas(
    vaults
      .reduce(
        (total, vault) =>
          total +
          (depositedAmounts[vault.address]
            ? parseFloat(depositedAmounts[vault.address]) * vault.price
            : 0),
        0
      )
      .toFixed(2)
  );

  const OPTIMISM_VAULT_MANAGER = "0x30bb5A1858D1CfE22AF5E028F15dD8450E76FDc3";
  const ARBITRUM_VAULT_MANAGER = "0x305c0C5001f40D8fa21740d1D135Cdbb7Fd97C53";
  const XEARN = "0xed6229CD962413CbcF07C8f9DD8D30607157Fff7";
  const WETH = "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619";

  const ARBITRUM_NODE_URI =
    "https://arb-mainnet.g.alchemy.com/v2/M4OMAtif3ZSHXjiTa0AT-lb_iKA0Lj3o"; // Plz don't use the api key
  const OPTIMISM_NODE_URI =
    "https://opt-mainnet.g.alchemy.com/v2/xhj3Bj3ukhHn3wUtCt76Bby0AmsUnmWp"; // Plz don't use the api key

  const arbitrumVaultManager = new ethers.Contract(
    ARBITRUM_VAULT_MANAGER,
    VAULT_MANAGER_ABI,
    new ethers.providers.JsonRpcProvider(ARBITRUM_NODE_URI)
  );

  const optimismVaultManager = new ethers.Contract(
    OPTIMISM_VAULT_MANAGER,
    VAULT_MANAGER_ABI,
    new ethers.providers.JsonRpcProvider(OPTIMISM_NODE_URI)
  );

  async function getShares(userAddress, vaultAddress, contractInstance) {
    return (
      await contractInstance.shares(userAddress, vaultAddress)
    ).toString();
  }

  async function fetchDepositedAmounts() {
    const amounts = {};

    for (const vault of vaults) {
      const contractInstance =
        vault.chainId === 10 ? optimismVaultManager : arbitrumVaultManager;
      const shares = await getShares(address, vault.address, contractInstance);
      amounts[vault.address] = shares;
    }

    setDepositedAmounts(amounts);
  }

  // Move hooks outside of the approve function
  const { config: approveConfig } = usePrepareContractWrite({
    address: WETH,
    abi: WETH_ABI,
    functionName: "approve",
    args: [XEARN, ethers.constants.MaxUint256],
    chainId: polygon.id,
  });

  const {
    data: approveData,
    isLoading: approveIsLoading,
    write,
  } = useContractWrite(approveConfig);

  // Update the approve function
  function approve() {
    write?.();
  }

  useEffect(() => {
    if (chain && chain.id !== 137) {
      switchNetwork(137);
    }
  }, [chain]);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    if (isConnected && address) {
      fetchDepositedAmounts();
    }
  }, [isConnected, address]);

  useEffect(() => {
    console.log(approveData);
  }, [approveData]);

  return (
    <div className={styles.container}>
      <Head>
        <title>xEarn</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
        <link
          rel="apple-touch-icon"
          sizes="180x180"
          href="/apple-touch-icon.png"
        />
        <link
          rel="icon"
          type="image/png"
          sizes="32x32"
          href="/favicon-32x32.png"
        />
        <link
          rel="icon"
          type="image/png"
          sizes="16x16"
          href="/favicon-16x16.png"
        />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
        <meta name="msapplication-TileColor" content="#00aba9" />
        <meta name="theme-color" content="#ffffff"></meta>
      </Head>

      <p className={styles.warning}>
        Warning! This project is an experiment, it's not audited and DEFINITELY
        has vulnerabilities. If you want to deposit in any vault you see, go to{" "}
        <a
          href="https://yearn.finance/vaults"
          target="_blank"
          className={styles.yearn}
        >
          Yearn Finance
        </a>
      </p>

      <header className={styles.header}>
        <img
          src="/logo.png"
          alt="Logo"
          width="50"
          className={styles.logoHeader}
        />
        {mounted && isConnected ? (
          <span onClick={disconnect} className={styles.address}>
            {shortenAddress(address)}
          </span>
        ) : (
          <button className={styles.connect} onClick={connect}>
            Connect wallet
          </button>
        )}
      </header>

      <main className={styles.main}>
        <div className={styles.balances}>
          <div className={styles.deposited}>
            <p className={styles.balanceText}>Deposited</p>
            <b className={styles.balanceAmount}>${depositedAmount}</b>
          </div>
          <div className={styles.earnings}>
            <p className={styles.balanceText}>Earnings</p>
            <b className={styles.balanceAmount}>$0,00</b>
          </div>
        </div>

        <button
          className={styles.approve}
          disabled={approveIsLoading}
          onClick={approve}
        >
          Approve WETH
        </button>

        <div className={styles.vaults}>
          <h2 className={styles.vaultsText}>All Vaults</h2>
          <table className={styles.table}>
            <thead>
              <tr>
                <th>Token</th>
                <th>APY</th>
                <th>Deposited</th>
                <th>TVL</th>
              </tr>
            </thead>
            <tbody>
              {vaults.map((row, index) => (
                <tr key={index} className={styles.tableRow}>
                  <td width="50%" className={styles.tokenRow}>
                    <img src={row.icon} alt={row.token} width="40px" />{" "}
                    <p className={styles.tokenText}>
                      {transformSymbol(row.token)}
                    </p>
                  </td>
                  <td>{row.apy}%</td>
                  <td
                    className={
                      depositedAmounts[row.address] &&
                      parseFloat(depositedAmounts[row.address]) > 0
                        ? ""
                        : styles.depositZero
                    }
                  >
                    {depositedAmounts[row.address]
                      ? parseFloat(depositedAmounts[row.address]).toFixed(2)
                      : "0.00"}
                  </td>
                  <td>${numberWithCommas(row.tvl)}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </main>

      <footer className={styles.footer}>
        <a
          href="https://twitter.com/chiin_rock"
          target="_blank"
          rel="noopener noreferrer"
        >
          Made with âœ– by Chiin
        </a>
      </footer>
    </div>
  );
}

export async function getStaticProps() {
  const endpoints = [
    "https://api.yearn.finance/v1/chains/10/vaults/all",
    "https://api.yearn.finance/v1/chains/42161/vaults/all",
  ];

  const responses = await Promise.all(endpoints.map((url) => fetch(url)));
  const [data1, data2] = await Promise.all(responses.map((res) => res.json()));
  const combinedData = [
    ...data1.map((vault) => ({ ...vault, chainId: 10 })),
    ...data2.map((vault) => ({ ...vault, chainId: 42161 })),
  ];

  const vaults = combinedData
    .map((vault) => ({
      address: vault.address,
      token: vault.token.symbol,
      icon: vault.token.icon,
      apy: (vault.apy.net_apy * 100).toFixed(2),
      price: vault.tvl.price,
      tvl: vault.tvl.tvl.toFixed(0),
    }))
    .filter((vault) => parseFloat(vault.tvl) > 0);

  const uniqueVaults = vaults.reduce((acc, vault) => {
    const existingVault = acc.find((v) => v.token === vault.token);

    if (existingVault) {
      if (parseFloat(vault.tvl) > parseFloat(existingVault.tvl)) {
        const index = acc.indexOf(existingVault);
        acc[index] = vault;
      }
    } else {
      acc.push(vault);
    }

    return acc;
  }, []);

  uniqueVaults.sort((a, b) => parseFloat(b.apy) - parseFloat(a.apy));

  return {
    props: {
      vaults: uniqueVaults,
    },
  };
}
